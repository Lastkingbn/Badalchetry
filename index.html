<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BNLASTKING </title>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #00ffea;
      --primary-transparent: #00ffea33;
      --primary-hover: #00ffea4d;
      --background: #000;
      --card-bg: #111;
      --table-border: #222;
      --analysis-box-bg: #222;
      --text-gray: #aaa;
    }
    body {
      font-family: 'Outfit', sans-serif;
      background: var(--background);
      color: #fff;
      margin: 0;
      padding: 10px;
      text-align: center;
      animation: slide-up-down 2s ease-in-out infinite;
    }
    .header {
      font-size: 20px;
      font-weight: bold;
      color: var(--primary-color);
      margin-bottom: 10px;
    }
    .card {
      background: var(--card-bg);
      border: 1px solid var(--primary-color);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 12px;
    }
    .prediction-btn {
      margin: 10px auto;
      display: block;
      background: var(--primary-transparent);
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
      border-radius: 8px;
      padding: 12px;
      font-weight: bold;
      font-size: 18px;
      transition: transform 0.2s;
    }
    .prediction-btn:hover {
      transform: scale(1.05);
    }
    #patternBox {
      color: var(--text-gray);
      font-size: 14px;
      margin-top: 5px;
    }
    .tab-buttons {
      display: flex;
      border: 1px solid var(--primary-color);
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    .tab-buttons button {
      flex: 1;
      background: var(--card-bg);
      color: var(--primary-color);
      padding: 8px;
      border: none;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s, transform 0.2s;
    }
    .tab-buttons button.active {
      background: var(--primary-transparent);
      transform: translateY(-2px);
    }
    .tab-buttons button:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
    }
    .history-container {
      border: 1px solid var(--primary-color);
      border-radius: 8px;
      overflow: hidden;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      font-size: 13px;
      border-bottom: 1px solid var(--table-border);
      padding: 6px;
    }
    th {
      background: var(--card-bg);
      color: var(--primary-color);
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }
    .dot.red { background: red; }
    .dot.green { background: lime; }
    .dot.violet { background: violet; }
    .num.red { color: red; font-weight: bold; }
    .num.green { color: lime; font-weight: bold; }
    .num.violet { color: violet; font-weight: bold; }
    .status {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      font-weight: bold;
      font-size: 12px;
    }
    .status.win { background: lime; color: #000; }
    .status.loss { background: red; color: #fff; }
    .status.pending { background: var(--text-gray); color: #000; }
    .analysis-dashboard {
      background: var(--card-bg);
      border: 1px solid var(--primary-color);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 12px;
    }
    .analysis-header {
      font-size: 16px;
      font-weight: bold;
      color: var(--primary-color);
      margin-bottom: 8px;
    }
    .analysis-content {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    .analysis-box {
      flex: 1;
      min-width: 100px;
      margin: 5px;
      padding: 8px;
      background: var(--analysis-box-bg);
      border: 1px solid var(--primary-color);
      border-radius: 8px;
      transition: transform 0.3s;
    }
    .analysis-box:hover {
      transform: translateY(-3px);
    }
    .online { color: lime; }
    .offline { color: red; }

    @keyframes slide-up-down {
      0% { transform: translateY(-10px); }
      50% { transform: translateY(10px); }
      100% { transform: translateY(-10px); }
    }
  </style>
</head>
<body>
  <div class="header">HEARTLASS KING <br><small>STARGES WIN SYSTEM ™</small></div>
  <div class="card">
    <div class="analysis-header">CURRENT PREDICTION</div>
    <div id="currentPeriod">Current Period: Loading...</div>
    <div id="liveTime">Time: --:--:--</div>
    <div id="predictionBox" class="prediction-btn">Prediction → Analyzing...</div>
    <div id="confidenceBox">Confidence: --%</div>
    <div id="patternBox"></div>
  </div>
  <div class="analysis-dashboard">
    <div class="analysis-header">ANALYSIS DASHBOARD</div>
    <div class="analysis-content">
      <div class="analysis-box">Total Wins: <span id="totalWins">0</span></div>
      <div class="analysis-box">Total Losses: <span id="totalLosses">0</span></div>
      <div class="analysis-box">Accuracy: <span id="accuracy">0%</span></div>
      <div class="analysis-box">Server Status: <span id="serverStatus" class="offline">Offline</span></div>
    </div>
  </div>
  <div class="tab-buttons">
    <button id="predTab" class="active">Prediction History</button>
    <button id="gameTab">Game History</button>
  </div>
  <div class="history-container">
    <table>
      <thead id="tableHead"></thead>
      <tbody id="tableBody"><tr><td>Loading...</td></tr></tbody>
    </table>
  </div>

  <script>
    // === STARGES WIN SYSTEM V2 – PURE WIN HUNTER ===
    const STARGES = {
      momentum: { BIG: 0, SMALL: 0 },
      heatMap: Array(10).fill(0),
      goldenPath: [],
      cosmicFlow: [],
      lastWinType: null,
      winStreak: 0
    };

    const STARGES_PREDICT = (history) => {
      if (history.length < 3) {
        const rand = Math.random() < 0.5 ? "BIG" : "SMALL";
        return { prediction: rand, confidence: 88, logic: "Cosmic Random Ignition" };
      }

      const recent = history.slice(0, 12);
      STARGES.heatMap = Array(10).fill(0);
      STARGES.momentum = { BIG: 0, SMALL: 0 };

      // Build Heat & Momentum
      recent.forEach((h, i) => {
        const weight = (12 - i);
        STARGES.heatMap[h.number] += weight;
        if (h.resultType === "BIG") STARGES.momentum.BIG += weight;
        else STARGES.momentum.SMALL += weight;
      });

      // Golden Path Detection (repeating win clusters)
      let golden = false;
      for (let i = 0; i < recent.length - 2; i++) {
        if (recent[i].resultType === recent[i+2].resultType && recent[i].resultType !== recent[i+1].resultType) {
          golden = true;
          STARGES.goldenPath.push(recent[i].resultType);
        }
      }

      // Cosmic Flow (last 3 same → explode opposite with 95%)
      const last3 = recent.slice(0, 3).map(r => r.resultType);
      if (last3[0] === last3[1] && last3[1] === last3[2]) {
        return { 
          prediction: last3[0] === "BIG" ? "SMALL" : "BIG", 
          confidence: 97, 
          logic: "TRIPLE COSMIC EXPLOSION → REVERSE" 
        };
      }

      // Golden Path Rider
      if (golden && STARGES.goldenPath.length >= 2) {
        const nextGolden = STARGES.goldenPath[STARGES.goldenPath.length - 1];
        return { prediction: nextGolden, confidence: 94, logic: "GOLDEN PATH RIDER ACTIVATED" };
      }

      // Momentum Surge
      const totalMomentum = STARGES.momentum.BIG + STARGES.momentum.SMALL;
      const bigRatio = STARGES.momentum.BIG / totalMomentum;
      if (bigRatio > 0.68) {
        return { prediction: "BIG", confidence: 92 + (bigRatio - 0.68) * 100, logic: "BIG MOMENTUM SURGE" };
      }
      if (bigRatio < 0.32) {
        return { prediction: "SMALL", confidence: 92 + (0.32 - bigRatio) * 100, logic: "SMALL MOMENTUM DOMINANCE" };
      }

      // Hot Number Chase
      const hottest = STARGES.heatMap.indexOf(Math.max(...STARGES.heatMap));
      const hotType = hottest >= 5 ? "BIG" : "SMALL";
      if (STARGES.heatMap[hottest] > 25) {
        return { prediction: hotType, confidence: 89, logic: `HOT NUMBER ${hottest} CHASE` };
      }

      // Default: Win Flow Continuation
      return { 
        prediction: recent[0].resultType, 
        confidence: 91, 
        logic: "WIN FLOW CONTINUATION" 
      };
    };

    // Configuration Constants
    const API_RETRY_INTERVAL = 3000;
    const API_MAX_RETRIES = 3;
    const UPDATE_INTERVAL = 5000;
    const MAX_HISTORY = 2880;
    const HISTORY_EXPIRY_MS = 24 * 60 * 60 * 1000;

    const CURRENT_API = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
    const HISTORY_API = 'https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json';

    const REQUEST_DATA = {
      typeId: 1,
      language: 0,
      random: "e7fe6c090da2495ab8290dac551ef1ed",
      signature: "1F390E2B2D8A55D693E57FD905AE73A7",
      timestamp: 1723726679
    };

    // Clean history & stats
    let predictionHistory = [];
    let stats = { wins: 0, losses: 0, accuracy: 0 };
    let lastFetchedPeriod = null;
    let lastPrediction = null;
    let isFetching = false;

    const formatPeriodNumber = () => {
      const now = new Date();
      now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
      const yearMonthDay = now.toISOString().slice(0, 10).replace(/-/g, '');
      const minutes = now.getHours() * 60 + now.getMinutes();
      return yearMonthDay + "1000" + (10001 + minutes);
    };

    const pad = (num) => num.toString().padStart(2, '0');
    const formatTimer = () => {
      const now = new Date();
      now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
      const seconds = now.getSeconds();
      return `${pad(0)}:${pad(60 - seconds)}`;
    };

    function getBigSmall(num) {
      return num >= 5 ? "BIG" : "SMALL";
    }

    function getColor(num) {
      if ([1, 3, 7, 9].includes(num)) return "Green";
      if ([2, 4, 6, 8].includes(num)) return "Red";
      return "Violet";
    }

    function updateLiveTime() {
      document.getElementById("liveTime").innerText = "Time: " + formatTimer();
    }

    function updateStats() {
      const total = stats.wins + stats.losses;
      stats.accuracy = total > 0 ? ((stats.wins / total) * 100).toFixed(2) : 0;
      document.getElementById("totalWins").innerText = stats.wins;
      document.getElementById("totalLosses").innerText = stats.losses;
      document.getElementById("accuracy").innerText = `${stats.accuracy}%`;
    }

    async function checkInternetSpeed() {
      const statusElement = document.getElementById("serverStatus");
      if (!navigator.onLine) {
        statusElement.innerText = "Offline";
        statusElement.className = "offline";
        return;
      }
      try {
        const startTime = performance.now();
        await fetch('https://www.google.com', { mode: 'no-cors' });
        const endTime = performance.now();
        const latency = Math.round(endTime - startTime);
        const speed = latency < 200 ? "Fast" : latency < 500 ? "Medium" : "Slow";
        statusElement.innerText = `Online (${speed}, ${latency}ms)`;
        statusElement.className = "online";
      } catch (e) {
        statusElement.innerText = "Offline";
        statusElement.className = "offline";
      }
    }

    const fetchHistory = async (retryCount = 0) => {
      if (isFetching) return null;
      isFetching = true;
      try {
        const res = await fetch(HISTORY_API + '?ts=' + Date.now());
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        const data = await res.json();
        if (!data?.data?.list) throw new Error("Invalid response structure");
        return data.data.list;
      } catch (e) {
        console.error("History fetch error:", e.message);
        if (retryCount < API_MAX_RETRIES) {
          await new Promise(resolve => setTimeout(resolve, API_RETRY_INTERVAL));
          return fetchHistory(retryCount + 1);
        }
        return [];
      } finally {
        isFetching = false;
      }
    };

    const fetchCurrentPeriod = async (retryCount = 0) => {
      try {
        const periodRes = await fetch(CURRENT_API, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ...REQUEST_DATA, timestamp: Math.floor(Date.now() / 1000) })
        });
        if (!periodRes.ok) throw new Error(`HTTP error! status: ${periodRes.status}`);
        const periodData = await periodRes.json();
        if (!periodData?.data?.issueNumber) throw new Error("Invalid response structure");
        return periodData.data.issueNumber;
      } catch (e) {
        console.error("Period fetch error:", e.message);
        if (retryCount < API_MAX_RETRIES) {
          await new Promise(resolve => setTimeout(resolve, API_RETRY_INTERVAL));
          return fetchCurrentPeriod(retryCount + 1);
        }
        return formatPeriodNumber();
      }
    };

    async function fetchData() {
      try {
        const period = await fetchCurrentPeriod();
        const list = await fetchHistory();
        let history = [];
        if (list.length > 0) {
          history = list.slice(0, 15).map(item => {
            const num = parseInt(item.number);
            return { period: item.issueNumber, number: num, resultType: getBigSmall(num), color: getColor(num) };
          });
        }

        if (period !== lastFetchedPeriod) {
          // Update previous result
          if (predictionHistory.length > 0 && predictionHistory[0].resultStatus === "Pending") {
            const match = history.find(h => h.period === predictionHistory[0].period);
            if (match) {
              const won = match.resultType === predictionHistory[0].prediction;
              predictionHistory[0].resultType = match.resultType;
              predictionHistory[0].resultStatus = won ? "WIN" : "LOSS";
              predictionHistory[0].number = match.number;
              if (won) stats.wins++; else stats.losses++;
              updateStats();
            }
          }

          // === STARGES PREDICTION ENGINE ===
          const starges = STARGES_PREDICT(history);
          lastPrediction = starges.prediction;

          document.getElementById("currentPeriod").innerText = `Current Period: ${period}`;
          document.getElementById("predictionBox").innerText = `Prediction → ${lastPrediction}`;
          document.getElementById("confidenceBox").innerText = `Confidence: ${starges.confidence}%`;
          document.getElementById("patternBox").innerText = starges.logic;

          if (!predictionHistory.find(p => p.period === period)) {
            predictionHistory.unshift({
              period: period,
              prediction: lastPrediction,
              resultType: "-",
              resultStatus: "Pending",
              number: null,
              timestamp: Date.now()
            });
          }

          // Auto-clean old data
          const now = Date.now();
          predictionHistory = predictionHistory.filter(p => now - p.timestamp < HISTORY_EXPIRY_MS);
          if (predictionHistory.length > MAX_HISTORY) predictionHistory = predictionHistory.slice(0, MAX_HISTORY);

          lastFetchedPeriod = period;
        }

        updateStats();
        renderTable();
      } catch (e) {
        console.error("Fetch error:", e.message);
      }
    }

    function renderTable() {
      const head = document.getElementById("tableHead");
      const body = document.getElementById("tableBody");

      if (document.getElementById("predTab").classList.contains("active")) {
        head.innerHTML = "<tr><th>Period</th><th>Prediction</th><th>Actual</th><th>Status</th></tr>";
        body.innerHTML = predictionHistory.length === 0
          ? "<tr><td colspan='4'>No predictions yet</td></tr>"
          : predictionHistory.map(item => `
            <tr>
              <td>${item.period}</td>
              <td>${item.prediction}</td>
              <td>${item.resultType}</td>
              <td><span class="status ${item.resultStatus.toLowerCase()}">${item.resultStatus.charAt(0)}</span></td>
            </tr>`).join("");
      } else {
        head.innerHTML = "<tr><th>Period</th><th>Number</th><th>Big/Small</th><th>Color</th></tr>";
        body.innerHTML = "<tr><td colspan='4'>Loading game history...</td></tr>";
        fetch(HISTORY_API + '?ts=' + Date.now())
          .then(res => res.ok ? res.json() : Promise.reject())
          .then(data => {
            if (!data?.data?.list) throw new Error();
            const hist = data.data.list.slice(0, 10).map(item => {
              const num = parseInt(item.number);
              return { period: item.issueNumber, number: num, size: getBigSmall(num), color: getColor(num).toLowerCase() };
            });
            body.innerHTML = hist.map(h => `
              <tr>
                <td>${h.period}</td>
                <td class="num ${h.color}">${h.number}</td>
                <td>${h.size}</td>
                <td><span class="dot ${h.color}"></span></td>
              </tr>`).join("");
          })
          .catch(() => body.innerHTML = "<tr><td colspan='4'>Error loading history</td></tr>");
      }
    }

    // Tab switching
    document.getElementById("predTab").onclick = () => {
      document.getElementById("predTab").classList.add("active");
      document.getElementById("gameTab").classList.remove("active");
      renderTable();
    };
    document.getElementById("gameTab").onclick = () => {
      document.getElementById("gameTab").classList.add("active");
      document.getElementById("predTab").classList.remove("active");
      renderTable();
    };

    // Init
    setInterval(updateLiveTime, 1000);
    setInterval(fetchData, UPDATE_INTERVAL);
    setInterval(checkInternetSpeed, 10000);
    fetchData();
    updateLiveTime();
    checkInternetSpeed();
  </script>
</body>
</html>