<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>HEART LASS KING - Advanced AI Prediction</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-cyan: #00ffea;
      --primary-blue: #0066ff;
      --primary-purple: #8b5cf6;
      --primary-pink: #ec4899;
      --success-green: #00ff88;
      --warning-orange: #ffaa00;
      --danger-red: #ff4444;
      --background-dark: #0a0a0f;
      --card-dark: #13131a;
      --card-lighter: #1a1a24;
      --border-glow: rgba(0, 255, 234, 0.3);
      --text-primary: #ffffff;
      --text-secondary: #a0aec0;
      --gradient-1: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --gradient-2: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      --gradient-3: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: var(--background-dark);
      color: var(--text-primary);
      overflow-x: hidden;
      position: relative;
      min-height: 100vh;
      padding: 20px;
    }
    
    /* Animated Background */
    #particles-js {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: 0;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    
    /* Header Section */
    .header {
      text-align: center;
      margin-bottom: 30px;
      animation: fadeInDown 0.6s ease;
    }
    
    .header h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 42px;
      font-weight: 900;
      background: linear-gradient(90deg, var(--primary-cyan), var(--primary-purple), var(--primary-pink));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(0, 255, 234, 0.5);
      margin-bottom: 10px;
      letter-spacing: 3px;
    }
    
    .header p {
      color: var(--text-secondary);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    
    /* Logic Selection Cards */
    .logic-selector {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
      animation: fadeInUp 0.6s ease 0.2s backwards;
    }
    
    .logic-card {
      background: var(--card-dark);
      border: 2px solid transparent;
      border-radius: 16px;
      padding: 24px;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    
    .logic-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--gradient-1);
      opacity: 0;
      transition: opacity 0.4s;
      z-index: 0;
    }
    
    .logic-card.logic-1::before { background: var(--gradient-1); }
    .logic-card.logic-2::before { background: var(--gradient-2); }
    .logic-card.logic-3::before { background: var(--gradient-3); }
    
    .logic-card:hover::before {
      opacity: 0.1;
    }
    
    .logic-card.active {
      border-color: var(--primary-cyan);
      transform: translateY(-5px);
      box-shadow: 0 10px 40px rgba(0, 255, 234, 0.3);
    }
    
    .logic-card.active::before {
      opacity: 0.15;
    }
    
    .logic-card-content {
      position: relative;
      z-index: 1;
    }
    
    .logic-icon {
      width: 50px;
      height: 50px;
      margin-bottom: 15px;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .logic-card h3 {
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      margin-bottom: 8px;
      color: var(--primary-cyan);
    }
    
    .logic-card p {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.6;
    }
    
    .logic-stats {
      margin-top: 15px;
      display: flex;
      justify-content: space-between;
      font-size: 12px;
    }
    
    .logic-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .logic-stat-value {
      font-weight: 700;
      font-size: 16px;
      color: var(--success-green);
    }
    
    .logic-stat-label {
      color: var(--text-secondary);
      margin-top: 4px;
    }
    
    /* Main Prediction Panel */
    .prediction-panel {
      background: var(--card-dark);
      border: 1px solid var(--border-glow);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 30px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      animation: fadeInUp 0.6s ease 0.4s backwards;
    }
    
    .period-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .period-number {
      font-family: 'Orbitron', sans-serif;
      font-size: 16px;
      color: var(--primary-cyan);
    }
    
    .period-timer {
      font-family: 'Orbitron', sans-serif;
      font-size: 24px;
      color: var(--warning-orange);
      font-weight: 700;
    }
    
    .prediction-display {
      text-align: center;
      margin: 30px 0;
    }
    
    .prediction-label {
      font-size: 14px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 15px;
    }
    
    .prediction-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 64px;
      font-weight: 900;
      background: linear-gradient(135deg, var(--primary-cyan), var(--primary-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 20px 0;
      animation: pulse 2s infinite;
      text-shadow: 0 0 30px rgba(0, 255, 234, 0.5);
    }
    
    .prediction-number {
      font-size: 48px;
      font-weight: 700;
      margin-top: 10px;
    }
    
    .confidence-bar-container {
      margin: 25px 0;
    }
    
    .confidence-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    .confidence-value {
      font-weight: 700;
      color: var(--success-green);
    }
    
    .confidence-bar {
      height: 12px;
      background: var(--card-lighter);
      border-radius: 20px;
      overflow: hidden;
      position: relative;
    }
    
    .confidence-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--success-green), var(--primary-cyan));
      border-radius: 20px;
      transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }
    
    .prediction-factors {
      background: var(--card-lighter);
      border-radius: 12px;
      padding: 20px;
      margin-top: 25px;
    }
    
    .factors-title {
      font-size: 14px;
      color: var(--primary-cyan);
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .factor-item {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    .factor-icon {
      width: 20px;
      height: 20px;
      margin-right: 10px;
      color: var(--primary-cyan);
    }
    
    /* Results Display */
    .results-section {
      animation: fadeInUp 0.6s ease 0.6s backwards;
    }
    
    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .results-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      color: var(--primary-cyan);
    }
    
    .stats-mini {
      display: flex;
      gap: 20px;
      font-size: 13px;
    }
    
    .stat-mini {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .stat-mini-value {
      font-weight: 700;
    }
    
    .stat-win { color: var(--success-green); }
    .stat-loss { color: var(--danger-red); }
    .stat-accuracy { color: var(--primary-cyan); }
    
    /* Results Grid */
    .results-grid {
      display: grid;
      gap: 15px;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    }
    
    .result-card {
      background: var(--card-dark);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .result-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: var(--success-green);
      transition: all 0.3s;
    }
    
    .result-card.win::before {
      background: var(--success-green);
      box-shadow: 0 0 20px var(--success-green);
    }
    
    .result-card.loss::before {
      background: var(--danger-red);
      box-shadow: 0 0 20px var(--danger-red);
    }
    
    .result-card.pending::before {
      background: var(--warning-orange);
      box-shadow: 0 0 20px var(--warning-orange);
    }
    
    .result-card:hover {
      transform: translateX(5px);
      border-color: var(--primary-cyan);
    }
    
    .result-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .result-period {
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      color: var(--text-secondary);
    }
    
    .result-status {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .result-status.win {
      background: rgba(0, 255, 136, 0.2);
      color: var(--success-green);
      border: 1px solid var(--success-green);
    }
    
    .result-status.loss {
      background: rgba(255, 68, 68, 0.2);
      color: var(--danger-red);
      border: 1px solid var(--danger-red);
    }
    
    .result-status.pending {
      background: rgba(255, 170, 0, 0.2);
      color: var(--warning-orange);
      border: 1px solid var(--warning-orange);
    }
    
    .result-body {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .result-prediction {
      display: flex;
      flex-direction: column;
    }
    
    .result-label {
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
      margin-bottom: 5px;
    }
    
    .result-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 24px;
      font-weight: 700;
    }
    
    .result-actual {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }
    
    .result-number {
      width: 50px;
      height: 50px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Orbitron', sans-serif;
      font-size: 24px;
      font-weight: 700;
      margin-top: 5px;
    }
    
    .result-number.red {
      background: linear-gradient(135deg, #ff4444, #cc0000);
      box-shadow: 0 4px 20px rgba(255, 68, 68, 0.4);
    }
    
    .result-number.green {
      background: linear-gradient(135deg, #00ff88, #00cc44);
      box-shadow: 0 4px 20px rgba(0, 255, 136, 0.4);
    }
    
    .result-number.violet {
      background: linear-gradient(135deg, #8b5cf6, #6d28d9);
      box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);
    }
    
    /* Analytics Dashboard */
    .analytics-panel {
      background: var(--card-dark);
      border: 1px solid var(--border-glow);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 30px;
      animation: fadeInUp 0.6s ease 0.8s backwards;
    }
    
    .analytics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }
    
    .analytics-card {
      background: var(--card-lighter);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      transition: transform 0.3s;
    }
    
    .analytics-card:hover {
      transform: translateY(-5px);
    }
    
    .analytics-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 32px;
      font-weight: 700;
      color: var(--primary-cyan);
      margin-bottom: 8px;
    }
    
    .analytics-label {
      font-size: 12px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    /* Floating Action Button */
    .fab-container {
      position: fixed;
      bottom: 30px;
      right: 30px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      z-index: 100;
    }
    
    .fab {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary-cyan), var(--primary-purple));
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 20px rgba(0, 255, 234, 0.4);
      transition: all 0.3s;
      color: white;
      font-size: 24px;
    }
    
    .fab:hover {
      transform: scale(1.1) rotate(90deg);
      box-shadow: 0 6px 30px rgba(0, 255, 234, 0.6);
    }
    
    .fab.muted {
      opacity: 0.5;
      background: var(--card-lighter);
    }
    
    /* Notifications */
    .notification {
      position: fixed;
      top: 30px;
      right: 30px;
      min-width: 300px;
      background: var(--card-dark);
      border: 1px solid var(--primary-cyan);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      transform: translateX(150%);
      transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
    }
    
    .notification.show {
      transform: translateX(0);
    }
    
    .notification.success {
      border-color: var(--success-green);
    }
    
    .notification.error {
      border-color: var(--danger-red);
    }
    
    .notification.warning {
      border-color: var(--warning-orange);
    }
    
    /* Animations */
    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
    }
    
    @keyframes glow {
      0%, 100% {
        box-shadow: 0 0 20px rgba(0, 255, 234, 0.3);
      }
      50% {
        box-shadow: 0 0 40px rgba(0, 255, 234, 0.6);
      }
    }
    
    /* Loader */
    .loader {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-cyan);
      animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      body {
        padding: 15px;
      }
      
      .header h1 {
        font-size: 32px;
      }
      
      .logic-selector {
        grid-template-columns: 1fr;
      }
      
      .prediction-value {
        font-size: 48px;
      }
      
      .results-grid {
        grid-template-columns: 1fr;
      }
      
      .fab-container {
        bottom: 20px;
        right: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="particles-js"></div>
  
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>HEART LASS KING</h1>
      <p>Advanced AI Prediction Engine</p>
    </div>
    
    <!-- Logic Selector -->
    <div class="logic-selector">
      <div class="logic-card logic-1 active" data-logic="1">
        <div class="logic-card-content">
          <div class="logic-icon">üéØ</div>
          <h3>Pattern Master</h3>
          <p>Analyzes sequential patterns, streaks, and alternation behaviors for precise predictions.</p>
          <div class="logic-stats">
            <div class="logic-stat">
              <div class="logic-stat-value" id="logic1-wins">0</div>
              <div class="logic-stat-label">Wins</div>
            </div>
            <div class="logic-stat">
              <div class="logic-stat-value" id="logic1-accuracy">0%</div>
              <div class="logic-stat-label">Accuracy</div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="logic-card logic-2" data-logic="2">
        <div class="logic-card-content">
          <div class="logic-icon">üìä</div>
          <h3>Frequency Analyzer</h3>
          <p>Uses statistical frequency analysis to identify hot and cold numbers for optimal predictions.</p>
          <div class="logic-stats">
            <div class="logic-stat">
              <div class="logic-stat-value" id="logic2-wins">0</div>
              <div class="logic-stat-label">Wins</div>
            </div>
            <div class="logic-stat">
              <div class="logic-stat-value" id="logic2-accuracy">0%</div>
              <div class="logic-stat-label">Accuracy</div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="logic-card logic-3" data-logic="3">
        <div class="logic-card-content">
          <div class="logic-icon">ü§ñ</div>
          <h3>Hybrid Intelligence</h3>
          <p>Combines multiple AI algorithms with entropy analysis for balanced and adaptive predictions.</p>
          <div class="logic-stats">
            <div class="logic-stat">
              <div class="logic-stat-value" id="logic3-wins">0</div>
              <div class="logic-stat-label">Wins</div>
            </div>
            <div class="logic-stat">
              <div class="logic-stat-value" id="logic3-accuracy">0%</div>
              <div class="logic-stat-label">Accuracy</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Main Prediction Panel -->
    <div class="prediction-panel">
      <div class="period-info">
        <div class="period-number" id="currentPeriod">
          Period: <span class="loader"></span>
        </div>
        <div class="period-timer" id="liveTime">00:60</div>
      </div>
      
      <div class="prediction-display">
        <div class="prediction-label">AI PREDICTION</div>
        <div class="prediction-value" id="predictionValue">
          <span class="loader"></span>
        </div>
        <div class="prediction-number" id="predictionNumber" style="display: none;"></div>
      </div>
      
      <div class="confidence-bar-container">
        <div class="confidence-label">
          <span>Confidence Level</span>
          <span class="confidence-value" id="confidenceValue">0%</span>
        </div>
        <div class="confidence-bar">
          <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
        </div>
      </div>
      
      <div class="prediction-factors" id="predictionFactors" style="display: none;">
        <div class="factors-title">Analysis Factors</div>
        <div id="factorsList"></div>
      </div>
    </div>
    
    <!-- Analytics Dashboard -->
    <div class="analytics-panel">
      <div class="analytics-grid">
        <div class="analytics-card">
          <div class="analytics-value" id="totalWins">0</div>
          <div class="analytics-label">Total Wins</div>
        </div>
        <div class="analytics-card">
          <div class="analytics-value" id="totalLosses">0</div>
          <div class="analytics-label">Total Losses</div>
        </div>
        <div class="analytics-card">
          <div class="analytics-value" id="overallAccuracy">0%</div>
          <div class="analytics-label">Overall Accuracy</div>
        </div>
        <div class="analytics-card">
          <div class="analytics-value" id="currentStreak">0</div>
          <div class="analytics-label">Win Streak</div>
        </div>
        <div class="analytics-card">
          <div class="analytics-value" id="serverStatus" class="offline">‚óè</div>
          <div class="analytics-label">Server Status</div>
        </div>
      </div>
    </div>
    
    <!-- Results Section -->
    <div class="results-section">
      <div class="results-header">
        <h2 class="results-title">Prediction History</h2>
        <div class="stats-mini">
          <div class="stat-mini">
            <span class="stat-mini-value stat-win" id="miniWins">0</span> Wins
          </div>
          <div class="stat-mini">
            <span class="stat-mini-value stat-loss" id="miniLosses">0</span> Losses
          </div>
          <div class="stat-mini">
            <span class="stat-mini-value stat-accuracy" id="miniAccuracy">0%</span> Success
          </div>
        </div>
      </div>
      
      <div class="results-grid" id="resultsGrid">
        <div class="result-card pending">
          <div class="result-header">
            <div class="result-period">Loading...</div>
            <div class="result-status pending">Pending</div>
          </div>
          <div class="result-body">
            <div class="result-prediction">
              <div class="result-label">Predicted</div>
              <div class="result-value">--</div>
            </div>
            <div class="result-actual">
              <div class="result-label">Actual</div>
              <div class="result-number" style="background: var(--card-lighter);">?</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Floating Action Buttons -->
  <div class="fab-container">
    <button class="fab" id="soundToggle" title="Toggle Sound">
      üîä
    </button>
  </div>
  
  <!-- Notification -->
  <div class="notification" id="notification">
    <div id="notificationMessage">Notification</div>
  </div>

  <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
  <script>
    // Configuration
    const API_CONFIG = {
      CURRENT_API: 'https://api.bdg88zf.com/api/webapi/GetGameIssue',
      HISTORY_API: 'https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json',
      UPDATE_INTERVAL: 5000,
      RETRY_INTERVAL: 3000,
      MAX_RETRIES: 3,
      REQUEST_DATA: {
        typeId: 1,
        language: 0,
        random: "e7fe6c090da2495ab8290dac551ef1ed",
        signature: "1F390E2B2D8A55D693E57FD905AE73A7",
        timestamp: 1723726679
      }
    };
    
    // State Management
    const state = {
      selectedLogic: 1,
      predictionHistory: [],
      lastFetchedPeriod: null,
      lastPrediction: null,
      soundEnabled: true,
      isFetching: false,
      gameHistory: [],
      stats: {
        logic1: { wins: 0, losses: 0, accuracy: 0 },
        logic2: { wins: 0, losses: 0, accuracy: 0 },
        logic3: { wins: 0, losses: 0, accuracy: 0 },
        overall: { wins: 0, losses: 0, accuracy: 0, streak: 0 }
      }
    };
    
    // Prediction Logic Classes
    class PatternMasterLogic {
      constructor() {
        this.name = "Pattern Master";
        this.history = [];
      }
      
      analyze(history) {
        if (history.length < 5) return null;
        
        const analysis = {
          streak: 0,
          alternation: 0,
          lastSize: history[0].number <= 4 ? 'small' : 'big'
        };
        
        let currentStreak = 1;
        let alternations = 0;
        
        for (let i = 1; i < Math.min(history.length, 20); i++) {
          const prevSize = history[i - 1].number <= 4 ? 'small' : 'big';
          const currentSize = history[i].number <= 4 ? 'small' : 'big';
          
          if (prevSize === currentSize) {
            currentStreak++;
          } else {
            analysis.streak = Math.max(analysis.streak, currentStreak);
            currentStreak = 1;
            alternations++;
          }
        }
        
        analysis.streak = Math.max(analysis.streak, currentStreak);
        analysis.alternation = alternations / (Math.min(history.length, 20) - 1);
        
        return analysis;
      }
      
      predict(history) {
        const analysis = this.analyze(history);
        if (!analysis) return this.randomPredict();
        
        const factors = [];
        let confidence = 0.5;
        let predictedSize = null;
        
        // Streak breaking logic
        if (analysis.streak >= 3) {
          predictedSize = analysis.lastSize === 'small' ? 'big' : 'small';
          confidence += 0.2;
          factors.push(`Breaking ${analysis.streak}-length streak`);
        }
        
        // Alternation pattern
        if (analysis.alternation > 0.7) {
          const altSize = analysis.lastSize === 'small' ? 'big' : 'small';
          if (!predictedSize) predictedSize = altSize;
          confidence += 0.15;
          factors.push(`High alternation rate (${(analysis.alternation * 100).toFixed(0)}%)`);
        }
        
        // Default prediction
        if (!predictedSize) {
          predictedSize = analysis.lastSize === 'small' ? 'big' : 'small';
          factors.push('Pattern reversal expected');
        }
        
        const numbers = predictedSize === 'small' ? [0, 1, 2, 3, 4] : [5, 6, 7, 8, 9];
        const predictedNumber = numbers[Math.floor(Math.random() * numbers.length)];
        
        return {
          size: predictedSize.toUpperCase(),
          number: predictedNumber,
          confidence: Math.min(0.95, confidence),
          factors: factors
        };
      }
      
      randomPredict() {
        const size = Math.random() > 0.5 ? 'BIG' : 'SMALL';
        const numbers = size === 'SMALL' ? [0, 1, 2, 3, 4] : [5, 6, 7, 8, 9];
        return {
          size: size,
          number: numbers[Math.floor(Math.random() * numbers.length)],
          confidence: 0.5,
          factors: ['Insufficient data for pattern analysis']
        };
      }
    }
    
    class FrequencyAnalyzerLogic {
      constructor() {
        this.name = "Frequency Analyzer";
        this.history = [];
      }
      
      analyze(history) {
        if (history.length < 10) return null;
        
        const frequency = { small: 0, big: 0, numbers: {} };
        
        history.slice(0, 30).forEach(item => {
          const size = item.number <= 4 ? 'small' : 'big';
          frequency[size]++;
          frequency.numbers[item.number] = (frequency.numbers[item.number] || 0) + 1;
        });
        
        return frequency;
      }
      
      predict(history) {
        const analysis = this.analyze(history);
        if (!analysis) return this.randomPredict();
        
        const factors = [];
        let confidence = 0.55;
        
        // Size frequency analysis
        const total = analysis.small + analysis.big;
        const smallRatio = analysis.small / total;
        let predictedSize = smallRatio < 0.45 ? 'SMALL' : smallRatio > 0.55 ? 'BIG' : (Math.random() > 0.5 ? 'BIG' : 'SMALL');
        
        if (smallRatio < 0.45) {
          confidence += 0.15;
          factors.push(`Small numbers underrepresented (${(smallRatio * 100).toFixed(0)}%)`);
        } else if (smallRatio > 0.55) {
          confidence += 0.15;
          factors.push(`Big numbers underrepresented (${((1-smallRatio) * 100).toFixed(0)}%)`);
        } else {
          factors.push('Balanced frequency distribution');
        }
        
        // Number frequency analysis
        const sortedNumbers = Object.entries(analysis.numbers).sort((a, b) => a[1] - b[1]);
        const leastFrequent = sortedNumbers.slice(0, 3).map(([num]) => parseInt(num));
        
        const numbers = predictedSize === 'SMALL' ? [0, 1, 2, 3, 4] : [5, 6, 7, 8, 9];
        const availableLeast = leastFrequent.filter(n => numbers.includes(n));
        
        const predictedNumber = availableLeast.length > 0 
          ? availableLeast[Math.floor(Math.random() * availableLeast.length)]
          : numbers[Math.floor(Math.random() * numbers.length)];
        
        factors.push(`Targeting cold number: ${predictedNumber}`);
        
        return {
          size: predictedSize,
          number: predictedNumber,
          confidence: Math.min(0.9, confidence),
          factors: factors
        };
      }
      
      randomPredict() {
        const size = Math.random() > 0.5 ? 'BIG' : 'SMALL';
        const numbers = size === 'SMALL' ? [0, 1, 2, 3, 4] : [5, 6, 7, 8, 9];
        return {
          size: size,
          number: numbers[Math.floor(Math.random() * numbers.length)],
          confidence: 0.5,
          factors: ['Insufficient data for frequency analysis']
        };
      }
    }
    
    class HybridIntelligenceLogic {
      constructor() {
        this.name = "Hybrid Intelligence";
        this.history = [];
      }
      
      analyze(history) {
        if (history.length < 10) return null;
        
        const analysis = {
          pattern: this.analyzePattern(history),
          frequency: this.analyzeFrequency(history),
          entropy: this.calculateEntropy(history),
          timePattern: this.analyzeTimePattern(history)
        };
        
        return analysis;
      }
      
      analyzePattern(history) {
        let streak = 1;
        let alternations = 0;
        
        for (let i = 1; i < Math.min(history.length, 15); i++) {
          const prevSize = history[i - 1].number <= 4 ? 'small' : 'big';
          const currentSize = history[i].number <= 4 ? 'small' : 'big';
          
          if (prevSize === currentSize) {
            streak++;
          } else {
            alternations++;
            streak = 1;
          }
        }
        
        return { streak, alternations };
      }
      
      analyzeFrequency(history) {
        const freq = { small: 0, big: 0 };
        history.slice(0, 20).forEach(item => {
          freq[item.number <= 4 ? 'small' : 'big']++;
        });
        return freq;
      }
      
      calculateEntropy(history) {
        const transitions = { 'SS': 0, 'SB': 0, 'BS': 0, 'BB': 0 };
        
        for (let i = 1; i < Math.min(history.length, 20); i++) {
          const prev = history[i - 1].number <= 4 ? 'S' : 'B';
          const curr = history[i].number <= 4 ? 'S' : 'B';
          transitions[prev + curr]++;
        }
        
        const total = Object.values(transitions).reduce((a, b) => a + b, 0);
        let entropy = 0;
        
        Object.values(transitions).forEach(count => {
          if (count > 0) {
            const p = count / total;
            entropy -= p * Math.log2(p);
          }
        });
        
        return entropy;
      }
      
      analyzeTimePattern(history) {
        const currentHour = new Date().getHours();
        return { hour: currentHour, isEvening: currentHour >= 18 && currentHour <= 23 };
      }
      
      predict(history) {
        const analysis = this.analyze(history);
        if (!analysis) return this.randomPredict();
        
        const factors = [];
        let confidence = 0.5;
        let scores = { small: 0, big: 0 };
        
        // Pattern analysis contribution
        if (analysis.pattern.streak >= 3) {
          const lastSize = history[0].number <= 4 ? 'small' : 'big';
          scores[lastSize === 'small' ? 'big' : 'small'] += 0.25;
          factors.push(`Streak breaking pattern (${analysis.pattern.streak} consecutive)`);
          confidence += 0.1;
        }
        
        // Frequency analysis contribution
        const total = analysis.frequency.small + analysis.frequency.big;
        const smallRatio = analysis.frequency.small / total;
        if (smallRatio < 0.4) {
          scores.small += 0.2;
          factors.push('Small frequency compensation');
          confidence += 0.08;
        } else if (smallRatio > 0.6) {
          scores.big += 0.2;
          factors.push('Big frequency compensation');
          confidence += 0.08;
        }
        
        // Entropy analysis
        if (analysis.entropy < 0.9) {
          scores[Math.random() > 0.5 ? 'small' : 'big'] += 0.1;
          factors.push(`Low entropy (${analysis.entropy.toFixed(2)}) - pattern detected`);
          confidence += 0.05;
        }
        
        // Time pattern
        if (analysis.timePattern.isEvening) {
          scores[Math.random() > 0.5 ? 'small' : 'big'] += 0.05;
          factors.push('Evening pattern adjustment');
        }
        
        const predictedSize = scores.small > scores.big ? 'SMALL' : 'BIG';
        const numbers = predictedSize === 'SMALL' ? [0, 1, 2, 3, 4] : [5, 6, 7, 8, 9];
        const predictedNumber = numbers[Math.floor(Math.random() * numbers.length)];
        
        if (factors.length === 0) {
          factors.push('Balanced hybrid analysis');
        }
        
        return {
          size: predictedSize,
          number: predictedNumber,
          confidence: Math.min(0.92, confidence + (Math.abs(scores.small - scores.big) * 0.5)),
          factors: factors
        };
      }
      
      randomPredict() {
        const size = Math.random() > 0.5 ? 'BIG' : 'SMALL';
        const numbers = size === 'SMALL' ? [0, 1, 2, 3, 4] : [5, 6, 7, 8, 9];
        return {
          size: size,
          number: numbers[Math.floor(Math.random() * numbers.length)],
          confidence: 0.5,
          factors: ['Insufficient data for hybrid analysis']
        };
      }
    }
    
    // Initialize Logic Engines
    const logicEngines = {
      1: new PatternMasterLogic(),
      2: new FrequencyAnalyzerLogic(),
      3: new HybridIntelligenceLogic()
    };
    
    // Utility Functions
    const formatTimer = () => {
      const now = new Date();
      now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
      const seconds = now.getSeconds();
      return `${String(0).padStart(2, '0')}:${String(60 - seconds).padStart(2, '0')}`;
    };
    
    const formatPeriodNumber = () => {
      const now = new Date();
      now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
      const yearMonthDay = now.toISOString().slice(0, 10).replace(/-/g, '');
      const minutes = now.getHours() * 60 + now.getMinutes();
      return yearMonthDay + "1000" + (10001 + minutes);
    };
    
    const getNumberColor = (num) => {
      if ([1, 3, 7, 9].includes(num)) return "green";
      if ([2, 4, 6, 8].includes(num)) return "red";
      return "violet";
    };
    
    const playSound = (type) => {
      if (!state.soundEnabled) return;
      
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        const frequencies = { win: 523.25, loss: 392.00, notification: 659.25 };
        oscillator.frequency.setValueAtTime(frequencies[type] || 440.00, audioContext.currentTime);
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
      } catch (e) {
        console.log("Audio not supported");
      }
    };
    
    const showNotification = (message, type = 'info', duration = 3000) => {
      const notification = document.getElementById('notification');
      const messageElement = document.getElementById('notificationMessage');
      
      messageElement.textContent = message;
      notification.className = `notification ${type}`;
      notification.classList.add('show');
      
      if (type !== 'info') {
        playSound('notification');
      }
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, duration);
    };
    
    // API Functions
    const fetchCurrentPeriod = async (retryCount = 0) => {
      try {
        const res = await fetch(API_CONFIG.CURRENT_API, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            ...API_CONFIG.REQUEST_DATA, 
            timestamp: Math.floor(Date.now() / 1000) 
          })
        });
        
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        const data = await res.json();
        if (!data?.data?.issueNumber) throw new Error("Invalid response");
        return data.data.issueNumber;
      } catch (e) {
        console.error("Period fetch error:", e.message);
        if (retryCount < API_CONFIG.MAX_RETRIES) {
          await new Promise(resolve => setTimeout(resolve, API_CONFIG.RETRY_INTERVAL));
          return fetchCurrentPeriod(retryCount + 1);
        }
        return formatPeriodNumber();
      }
    };
    
    const fetchHistory = async (retryCount = 0) => {
      if (state.isFetching) return [];
      state.isFetching = true;
      
      try {
        const res = await fetch(API_CONFIG.HISTORY_API + '?ts=' + Date.now());
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        const data = await res.json();
        if (!data?.data?.list) throw new Error("Invalid response");
        return data.data.list;
      } catch (e) {
        console.error("History fetch error:", e.message);
        if (retryCount < API_CONFIG.MAX_RETRIES) {
          await new Promise(resolve => setTimeout(resolve, API_CONFIG.RETRY_INTERVAL));
          return fetchHistory(retryCount + 1);
        }
        return [];
      } finally {
        state.isFetching = false;
      }
    };
    
    // Update Functions
    const updateLiveTime = () => {
      document.getElementById('liveTime').textContent = formatTimer();
    };
    
    const updateStats = () => {
      // Update overall stats
      const total = state.stats.overall.wins + state.stats.overall.losses;
      state.stats.overall.accuracy = total > 0 ? ((state.stats.overall.wins / total) * 100).toFixed(1) : 0;
      
      document.getElementById('totalWins').textContent = state.stats.overall.wins;
      document.getElementById('totalLosses').textContent = state.stats.overall.losses;
      document.getElementById('overallAccuracy').textContent = state.stats.overall.accuracy + '%';
      document.getElementById('currentStreak').textContent = state.stats.overall.streak;
      
      document.getElementById('miniWins').textContent = state.stats.overall.wins;
      document.getElementById('miniLosses').textContent = state.stats.overall.losses;
      document.getElementById('miniAccuracy').textContent = state.stats.overall.accuracy + '%';
      
      // Update logic-specific stats
      for (let i = 1; i <= 3; i++) {
        const logicStats = state.stats[`logic${i}`];
        const total = logicStats.wins + logicStats.losses;
        logicStats.accuracy = total > 0 ? ((logicStats.wins / total) * 100).toFixed(1) : 0;
        
        document.getElementById(`logic${i}-wins`).textContent = logicStats.wins;
        document.getElementById(`logic${i}-accuracy`).textContent = logicStats.accuracy + '%';
      }
    };
    
    const updatePrediction = (prediction) => {
      document.getElementById('predictionValue').textContent = prediction.size;
      document.getElementById('predictionNumber').textContent = `Number: ${prediction.number}`;
      document.getElementById('predictionNumber').style.display = 'block';
      
      const confidence = Math.round(prediction.confidence * 100);
      document.getElementById('confidenceValue').textContent = confidence + '%';
      document.getElementById('confidenceFill').style.width = confidence + '%';
      
      if (prediction.factors && prediction.factors.length > 0) {
        const factorsList = document.getElementById('factorsList');
        factorsList.innerHTML = prediction.factors.map(factor => 
          `<div class="factor-item">
            <div class="factor-icon">‚úì</div>
            <span>${factor}</span>
          </div>`
        ).join('');
        document.getElementById('predictionFactors').style.display = 'block';
      } else {
        document.getElementById('predictionFactors').style.display = 'none';
      }
    };
    
    const renderResults = () => {
      const grid = document.getElementById('resultsGrid');
      
      if (state.predictionHistory.length === 0) {
        grid.innerHTML = `
          <div class="result-card pending">
            <div class="result-header">
              <div class="result-period">No predictions yet</div>
              <div class="result-status pending">Pending</div>
            </div>
          </div>
        `;
        return;
      }
      
      grid.innerHTML = state.predictionHistory.slice(0, 20).map(item => {
        const statusClass = item.status === 'WIN' ? 'win' : item.status === 'LOSS' ? 'loss' : 'pending';
        const numberColor = item.actualNumber !== null ? getNumberColor(item.actualNumber) : '';
        
        return `
          <div class="result-card ${statusClass}">
            <div class="result-header">
              <div class="result-period">${item.period}</div>
              <div class="result-status ${statusClass}">${item.status}</div>
            </div>
            <div class="result-body">
              <div class="result-prediction">
                <div class="result-label">Predicted</div>
                <div class="result-value">${item.prediction}</div>
              </div>
              <div class="result-actual">
                <div class="result-label">Actual</div>
                <div class="result-number ${numberColor}">
                  ${item.actualNumber !== null ? item.actualNumber : '?'}
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    };
    
    const checkServerStatus = async () => {
      const statusElement = document.getElementById('serverStatus');
      
      if (!navigator.onLine) {
        statusElement.textContent = '‚óè';
        statusElement.style.color = 'var(--danger-red)';
        return;
      }
      
      try {
        const startTime = performance.now();
        await fetch('https://www.google.com', { mode: 'no-cors' });
        const endTime = performance.now();
        const latency = Math.round(endTime - startTime);
        
        statusElement.textContent = '‚óè';
        statusElement.style.color = latency < 200 ? 'var(--success-green)' : 'var(--warning-orange)';
      } catch (e) {
        statusElement.textContent = '‚óè';
        statusElement.style.color = 'var(--danger-red)';
      }
    };
    
    // Main Data Fetch
    const fetchData = async () => {
      try {
        const period = await fetchCurrentPeriod();
        const historyList = await fetchHistory();
        
        if (historyList.length > 0) {
          state.gameHistory = historyList.slice(0, 50).map(item => ({
            period: item.issueNumber,
            number: parseInt(item.number),
            timestamp: Date.now()
          }));
        }
        
        if (period !== state.lastFetchedPeriod) {
          // Check previous prediction
          if (state.predictionHistory.length > 0 && state.predictionHistory[0].status === 'PENDING') {
            const match = state.gameHistory.find(h => h.period === state.predictionHistory[0].period);
            if (match) {
              const actualSize = match.number >= 5 ? 'BIG' : 'SMALL';
              const isWin = state.predictionHistory[0].prediction === actualSize;
              
              state.predictionHistory[0].status = isWin ? 'WIN' : 'LOSS';
              state.predictionHistory[0].actualNumber = match.number;
              
              // Update stats
              const logicKey = `logic${state.predictionHistory[0].logic}`;
              if (isWin) {
                state.stats[logicKey].wins++;
                state.stats.overall.wins++;
                state.stats.overall.streak++;
                playSound('win');
                showNotification(`üéâ WIN! Prediction was correct using ${logicEngines[state.predictionHistory[0].logic].name}`, 'success');
              } else {
                state.stats[logicKey].losses++;
                state.stats.overall.losses++;
                state.stats.overall.streak = 0;
                playSound('loss');
                showNotification(`‚ùå LOSS! Prediction was incorrect`, 'error');
              }
              
              updateStats();
              renderResults();
            }
          }
          
          // Generate new prediction
          const currentLogic = logicEngines[state.selectedLogic];
          const prediction = currentLogic.predict(state.gameHistory);
          
          updatePrediction(prediction);
          
          state.predictionHistory.unshift({
            period: period,
            prediction: prediction.size,
            predictedNumber: prediction.number,
            actualNumber: null,
            status: 'PENDING',
            logic: state.selectedLogic,
            confidence: prediction.confidence
          });
          
          state.lastPrediction = prediction.size;
          state.lastFetchedPeriod = period;
          
          document.getElementById('currentPeriod').textContent = `Period: ${period}`;
          
          renderResults();
        }
      } catch (e) {
        console.error("Error in fetchData:", e);
        showNotification("Error fetching data. Retrying...", "error");
      }
    };
    
    // Event Listeners
    document.querySelectorAll('.logic-card').forEach(card => {
      card.addEventListener('click', () => {
        document.querySelectorAll('.logic-card').forEach(c => c.classList.remove('active'));
        card.classList.add('active');
        state.selectedLogic = parseInt(card.dataset.logic);
        showNotification(`Switched to ${logicEngines[state.selectedLogic].name}`, 'success', 2000);
      });
    });
    
    document.getElementById('soundToggle').addEventListener('click', () => {
      state.soundEnabled = !state.soundEnabled;
      const btn = document.getElementById('soundToggle');
      
      if (state.soundEnabled) {
        btn.classList.remove('muted');
        btn.textContent = 'üîä';
        showNotification('Sound enabled', 'success', 2000);
      } else {
        btn.classList.add('muted');
        btn.textContent = 'üîá';
        showNotification('Sound disabled', 'info', 2000);
      }
    });
    
    // Initialize Particles
    const initParticles = () => {
      particlesJS('particles-js', {
        particles: {
          number: { value: 60, density: { enable: true, value_area: 800 } },
          color: { value: "#00ffea" },
          shape: { type: "circle" },
          opacity: { value: 0.3, random: true },
          size: { value: 3, random: true },
          line_linked: {
            enable: true,
            distance: 150,
            color: "#00ffea",
            opacity: 0.2,
            width: 1
          },
          move: {
            enable: true,
            speed: 2,
            direction: "none",
            random: true,
            straight: false,
            out_mode: "out",
            bounce: false
          }
        },
        interactivity: {
          detect_on: "canvas",
          events: {
            onhover: { enable: true, mode: "repulse" },
            onclick: { enable: true, mode: "push" },
            resize: true
          }
        },
        retina_detect: true
      });
    };
    
    // Initialize Application
    const init = () => {
      initParticles();
      updateLiveTime();
      checkServerStatus();
      fetchData();
      
      setInterval(updateLiveTime, 1000);
      setInterval(fetchData, API_CONFIG.UPDATE_INTERVAL);
      setInterval(checkServerStatus, 10000);
      
      setTimeout(() => {
        showNotification('üöÄ HEART LASS KING Engine Activated', 'success', 4000);
      }, 1000);
    };
    
    // Start
    init();
  </script>
</body>
</html>
