<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title> HEART LASS KING </title>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #00ffea;
      --primary-transparent: #00ffea33;
      --primary-hover: #00ffea4d;
      --background: #000;
      --card-bg: #111;
      --table-border: #222;
      --analysis-box-bg: #222;
      --text-gray: #aaa;
      --success-color: #00ff88;
      --warning-color: #ffaa00;
      --danger-color: #ff4444;
    }
    
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Outfit', sans-serif;
      background: var(--background);
      color: #fff;
      margin: 0;
      padding: 10px;
      text-align: center;
      overflow-x: hidden;
      position: relative;
    }
    
    /* Particle Background */
    #particles-js {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: -1;
    }
    
    .header {
      font-size: 20px;
      font-weight: bold;
      color: var(--primary-color);
      margin-bottom: 10px;
      text-shadow: 0 0 10px var(--primary-color);
      position: relative;
      z-index: 1;
    }
    
    .card {
      background: var(--card-bg);
      border: 1px solid var(--primary-color);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 12px;
      box-shadow: 0 0 15px var(--primary-transparent);
      position: relative;
      z-index: 1;
      transition: all 0.3s ease;
    }
    
    .card:hover {
      box-shadow: 0 0 20px var(--primary-transparent);
    }
    
    .prediction-btn {
      margin: 10px auto;
      display: block;
      background: var(--primary-transparent);
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
      border-radius: 8px;
      padding: 12px;
      font-weight: bold;
      font-size: 18px;
      transition: transform 0.2s;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    
    .prediction-btn:hover {
      transform: scale(1.05);
    }
    
    .prediction-btn::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(
        to bottom right,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.1) 50%,
        rgba(255, 255, 255, 0) 100%
      );
      transform: rotate(30deg);
      transition: all 0.6s;
    }
    
    .prediction-btn:hover::after {
      left: 100%;
    }
    
    #patternBox {
      color: var(--text-gray);
      font-size: 14px;
      margin-top: 5px;
    }
    
    .tab-buttons {
      display: flex;
      border: 1px solid var(--primary-color);
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 10px;
      position: relative;
      z-index: 1;
    }
    
    .tab-buttons button {
      flex: 1;
      background: var(--card-bg);
      color: var(--primary-color);
      padding: 8px;
      border: none;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s, transform 0.2s;
    }
    
    .tab-buttons button.active {
      background: var(--primary-transparent);
      transform: translateY(-2px);
    }
    
    .tab-buttons button:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
    }
    
    .history-container {
      border: 1px solid var(--primary-color);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      z-index: 1;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
    }
    
    th, td {
      font-size: 13px;
      border-bottom: 1px solid var(--table-border);
      padding: 6px;
    }
    
    th {
      background: var(--card-bg);
      color: var(--primary-color);
    }
    
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }
    
    .dot.red { background: var(--danger-color); }
    .dot.green { background: var(--success-color); }
    .dot.violet { background: violet; }
    
    .num.red { color: var(--danger-color); font-weight: bold; }
    .num.green { color: var(--success-color); font-weight: bold; }
    .num.violet { color: violet; font-weight: bold; }
    
    .status {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      font-weight: bold;
      font-size: 12px;
    }
    
    .status.win { background: var(--success-color); color: #000; }
    .status.loss { background: var(--danger-color); color: #fff; }
    .status.pending { background: var(--text-gray); color: #000; }
    
    .analysis-dashboard {
      background: var(--card-bg);
      border: 1px solid var(--primary-color);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 12px;
      position: relative;
      z-index: 1;
    }
    
    .analysis-header {
      font-size: 16px;
      font-weight: bold;
      color: var(--primary-color);
      margin-bottom: 8px;
    }
    
    .analysis-content {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    
    .analysis-box {
      flex: 1;
      min-width: 100px;
      margin: 5px;
      padding: 8px;
      background: var(--analysis-box-bg);
      border: 1px solid var(--primary-color);
      border-radius: 8px;
      transition: transform 0.3s;
    }
    
    .analysis-box:hover {
      transform: translateY(-3px);
    }
    
    .online { color: var(--success-color); }
    .offline { color: var(--danger-color); }
    
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 8px;
      background: var(--card-bg);
      border: 1px solid var(--primary-color);
      box-shadow: 0 0 15px var(--primary-transparent);
      z-index: 1000;
      transform: translateX(150%);
      transition: transform 0.5s ease;
    }
    
    .notification.show {
      transform: translateX(0);
    }
    
    .notification.success {
      border-color: var(--success-color);
    }
    
    .notification.warning {
      border-color: var(--warning-color);
    }
    
    .notification.error {
      border-color: var(--danger-color);
    }
    
    .sound-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: var(--card-bg);
      border: 1px solid var(--primary-color);
      color: var(--primary-color);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s;
    }
    
    .sound-toggle:hover {
      transform: scale(1.1);
      box-shadow: 0 0 10px var(--primary-transparent);
    }
    
    .sound-toggle.muted {
      opacity: 0.5;
    }
    
    .prediction-animation {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    
    .pulse {
      position: absolute;
      border-radius: 50%;
      background: var(--primary-color);
      opacity: 0;
      animation: pulse 1.5s ease-out infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(0.1);
        opacity: 0.8;
      }
      100% {
        transform: scale(2);
        opacity: 0;
      }
    }
    
    .loader {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .prediction-result {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 10px 0;
    }
    
    .result-indicator {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      margin: 0 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
    }
    
    .result-indicator.win {
      background: var(--success-color);
      color: #000;
    }
    
    .result-indicator.loss {
      background: var(--danger-color);
      color: #fff;
    }
    
    .result-indicator.pending {
      background: var(--text-gray);
      color: #000;
    }
    
    .streak-indicator {
      display: flex;
      justify-content: center;
      margin: 10px 0;
    }
    
    .streak-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin: 0 3px;
      background: var(--text-gray);
    }
    
    .streak-dot.active {
      background: var(--success-color);
    }
    
    .streak-dot.loss {
      background: var(--danger-color);
    }
    
    .prediction-details {
      margin-top: 10px;
      padding: 10px;
      background: var(--analysis-box-bg);
      border-radius: 8px;
      font-size: 12px;
      text-align: left;
    }
    
    .prediction-details h4 {
      margin: 0 0 5px 0;
      color: var(--primary-color);
    }
    
    .prediction-details ul {
      margin: 0;
      padding-left: 15px;
    }
    
    .prediction-details li {
      margin-bottom: 3px;
    }
  </style>
</head>
<body>
  <div id="particles-js"></div>
  
  <div class="header">HEART LASS KING</div>
  
  <div class="card">
    <div class="analysis-header">AI PREDICTION ENGINE</div>
    <div id="currentPeriod">Current Period: <span class="loader"></span></div>
    <div id="liveTime">Time: --:--:--</div>
    <div id="predictionBox" class="prediction-btn">AI Analyzing <span class="loader"></span></div>
    <div id="confidenceBox">Confidence: --%</div>
    <div id="patternBox"></div>
    
    <div class="prediction-result">
      <div class="result-indicator pending">?</div>
    </div>
    
    <div class="streak-indicator">
      <div class="streak-dot"></div>
      <div class="streak-dot"></div>
      <div class="streak-dot"></div>
      <div class="streak-dot"></div>
      <div class="streak-dot"></div>
    </div>
    
    <div class="prediction-details" id="predictionDetails" style="display: none;">
      <h4>Prediction Analysis</h4>
      <ul id="predictionFactors">
        <!-- Factors will be populated here -->
      </ul>
    </div>
  </div>
  
  <div class="analysis-dashboard">
    <div class="analysis-header">AI ANALYSIS DASHBOARD</div>
    <div class="analysis-content">
      <div class="analysis-box">Total Wins: <span id="totalWins">0</span></div>
      <div class="analysis-box">Total Losses: <span id="totalLosses">0</span></div>
      <div class="analysis-box">Accuracy: <span id="accuracy">0%</span></div>
      <div class="analysis-box">Server Status: <span id="serverStatus" class="offline">Offline</span></div>
    </div>
  </div>
  
  <div class="tab-buttons">
    <button id="predTab" class="active">Prediction History</button>
    <button id="gameTab">Game History</button>
    <button id="aiTab">AI Analysis</button>
  </div>
  
  <div class="history-container">
    <table>
      <thead id="tableHead"></thead>
      <tbody id="tableBody"><tr><td>Loading...</td></tr></tbody>
    </table>
  </div>
  
  <div class="notification" id="notification">
    <div id="notificationMessage">Notification</div>
  </div>
  
  <div class="sound-toggle" id="soundToggle">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
      <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
    </svg>
  </div>

  <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
  <script>
    // Configuration Constants
    const API_RETRY_INTERVAL = 3000;
    const API_MAX_RETRIES = 3;
    const UPDATE_INTERVAL = 5000;
    const MAX_HISTORY = 2880;
    const HISTORY_EXPIRY_MS = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
    const MAX_DAILY_PATTERNS = 7;

    const CURRENT_API = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
    const HISTORY_API = 'https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json';

    const REQUEST_DATA = {
      typeId: 1,
      language: 0,
      random: "e7fe6c090da2495ab8290dac551ef1ed",
      signature: "1F390E2B2D8A55D693E57FD905AE73A7",
      timestamp: 1723726679
    };

    // Initialize variables
    let predictionHistory = [];
    let dailyPatterns = {};
    let stats = { wins: 0, losses: 0, streak: 0, accuracy: 0 };
    let lastFetchedPeriod = null;
    let lastPrediction = null;
    let winLevel = 0;
    let consecutiveLosses = 0;
    let isFetching = false;
    let soundEnabled = true;
    let notificationQueue = [];
    let isShowingNotification = false;

    // Initialize Advanced AI Predictor
    class AdvancedAIPredictor {
      constructor() {
        this.history = [];
        this.patternWeights = { 
          streak: 0.25, 
          alternation: 0.2, 
          frequency: 0.15, 
          randomness: 0.1,
          timePattern: 0.1,
          clusterAnalysis: 0.1,
          entropy: 0.1
        };
        this.lastPrediction = null;
        this.accuracyStats = { correct: 0, total: 0 };
        this.patternMemory = [];
        this.timePatterns = {};
      }

      // Advanced pattern analysis
      analyzeAdvancedPatterns(history) {
        if (history.length < 5) return null;
        
        const analysis = {
          sizeStreak: 0,
          sizeAlternation: 0,
          numberFrequency: {},
          lastNumbers: history.slice(0, 10).map(item => item.number),
          timePattern: this.analyzeTimePatterns(history),
          clusterAnalysis: this.analyzeClusters(history),
          entropy: this.calculateEntropy(history)
        };

        // Size streak analysis
        let currentStreak = 1;
        let alternations = 0;
        for (let i = 1; i < history.length; i++) {
          const prevSize = history[i - 1].number <= 4 ? 'small' : 'big';
          const currentSize = history[i].number <= 4 ? 'small' : 'big';
          if (prevSize === currentSize) {
            currentStreak++;
          } else {
            analysis.sizeStreak = Math.max(analysis.sizeStreak, currentStreak);
            currentStreak = 1;
            alternations++;
          }
          analysis.numberFrequency[history[i].number] = (analysis.numberFrequency[history[i].number] || 0) + 1;
        }
        analysis.sizeStreak = Math.max(analysis.sizeStreak, currentStreak);
        analysis.sizeAlternation = alternations / (history.length - 1);

        return analysis;
      }

      // Analyze time-based patterns
      analyzeTimePatterns(history) {
        const timePatterns = {};
        history.forEach(item => {
          if (item.timestamp) {
            const hour = new Date(item.timestamp).getHours();
            timePatterns[hour] = timePatterns[hour] || { small: 0, big: 0 };
            timePatterns[hour][item.number <= 4 ? 'small' : 'big']++;
          }
        });
        return timePatterns;
      }

      // Cluster analysis for number grouping
      analyzeClusters(history) {
        const clusters = { small: [], big: [] };
        let currentCluster = { type: null, length: 0 };
        
        history.forEach(item => {
          const type = item.number <= 4 ? 'small' : 'big';
          if (currentCluster.type === type) {
            currentCluster.length++;
          } else {
            if (currentCluster.type) {
              clusters[currentCluster.type].push(currentCluster.length);
            }
            currentCluster = { type, length: 1 };
          }
        });
        
        if (currentCluster.type) {
          clusters[currentCluster.type].push(currentCluster.length);
        }
        
        return {
          smallAvg: clusters.small.length ? clusters.small.reduce((a, b) => a + b, 0) / clusters.small.length : 0,
          bigAvg: clusters.big.length ? clusters.big.reduce((a, b) => a + b, 0) / clusters.big.length : 0,
          smallMax: clusters.small.length ? Math.max(...clusters.small) : 0,
          bigMax: clusters.big.length ? Math.max(...clusters.big) : 0
        };
      }

      // Calculate entropy of the sequence
      calculateEntropy(history) {
        const sizeSequence = history.map(item => item.number <= 4 ? 'S' : 'B');
        const transitions = {
          'S->S': 0,
          'S->B': 0,
          'B->S': 0,
          'B->B': 0
        };
        
        for (let i = 1; i < sizeSequence.length; i++) {
          const transition = `${sizeSequence[i-1]}->${sizeSequence[i]}`;
          transitions[transition]++;
        }
        
        const totalTransitions = sizeSequence.length - 1;
        let entropy = 0;
        
        Object.values(transitions).forEach(count => {
          if (count > 0) {
            const probability = count / totalTransitions;
            entropy -= probability * Math.log2(probability);
          }
        });
        
        return entropy;
      }

      // Generate prediction with advanced logic
      generatePrediction(analysis) {
        if (!analysis) return this.generateSmartRandomPrediction();
        
        const prediction = { 
          number: null, 
          size: null, 
          confidence: 0.5, 
          reasoning: [],
          factors: []
        };

        // Factor 1: Streak breaking
        if (analysis.sizeStreak >= 3) {
          const expectedBreakSize = analysis.lastNumbers[0] <= 4 ? 'big' : 'small';
          prediction.size = expectedBreakSize;
          prediction.confidence += 0.15;
          prediction.factors.push(`Breaking ${analysis.sizeStreak}-length streak`);
        }

        // Factor 2: Alternation pattern
        if (analysis.sizeAlternation > 0.7) {
          const expectedAlternation = analysis.lastNumbers[0] <= 4 ? 'big' : 'small';
          if (!prediction.size) prediction.size = expectedAlternation;
          prediction.confidence += 0.1;
          prediction.factors.push(`High alternation rate (${(analysis.sizeAlternation * 100).toFixed(0)}%)`);
        }

        // Factor 3: Frequency analysis
        const sortedNumbers = Object.entries(analysis.numberFrequency).sort((a, b) => a[1] - b[1]);
        if (sortedNumbers.length > 0) {
          const leastFrequent = parseInt(sortedNumbers[0][0]);
          if (!prediction.number) prediction.number = leastFrequent;
          prediction.confidence += 0.08;
          prediction.factors.push(`Least frequent number: ${leastFrequent}`);
        }

        // Factor 4: Time-based patterns
        const currentHour = new Date().getHours();
        if (analysis.timePattern[currentHour]) {
          const timeStats = analysis.timePattern[currentHour];
          const total = timeStats.small + timeStats.big;
          const smallRatio = timeStats.small / total;
          
          if (Math.abs(smallRatio - 0.5) > 0.2) {
            const timeBasedPrediction = smallRatio > 0.5 ? 'small' : 'big';
            if (!prediction.size) prediction.size = timeBasedPrediction;
            prediction.confidence += 0.07;
            prediction.factors.push(`Time pattern (${currentHour}:00) favors ${timeBasedPrediction}`);
          }
        }

        // Factor 5: Cluster analysis
        if (analysis.clusterAnalysis.smallAvg > 2.5 || analysis.clusterAnalysis.bigAvg > 2.5) {
          const clusterBasedPrediction = analysis.clusterAnalysis.smallAvg > analysis.clusterAnalysis.bigAvg ? 'big' : 'small';
          if (!prediction.size) prediction.size = clusterBasedPrediction;
          prediction.confidence += 0.05;
          prediction.factors.push(`Cluster analysis favors ${clusterBasedPrediction}`);
        }

        // Factor 6: Entropy-based prediction
        if (analysis.entropy < 0.8) {
          prediction.confidence += 0.05;
          prediction.factors.push(`Low entropy (${analysis.entropy.toFixed(2)}) indicates pattern`);
        }

        // Fallback to weighted random if no strong pattern
        if (!prediction.size && !prediction.number) {
          return this.generateWeightedRandomPrediction(analysis);
        }

        // Finalize prediction
        if (!prediction.number) {
          const possibleNumbers = prediction.size === 'small' ? [0, 1, 2, 3, 4] : [5, 6, 7, 8, 9];
          prediction.number = possibleNumbers[Math.floor(Math.random() * possibleNumbers.length)];
        } else if (!prediction.size) {
          prediction.size = prediction.number <= 4 ? 'small' : 'big';
        }

        prediction.confidence = Math.min(0.95, Math.max(0.4, prediction.confidence));
        prediction.reasoning = prediction.factors.join('; ');
        
        return prediction;
      }

      generateWeightedRandomPrediction(analysis) {
        const numberWeights = Array(10).fill(1);
        
        // Apply frequency-based weighting
        for (const [num, count] of Object.entries(analysis.numberFrequency)) {
          numberWeights[num] = 1 / (count + 1);
        }
        
        // Apply recency weighting (more recent numbers have slightly higher weight)
        analysis.lastNumbers.slice(0, 5).forEach(num => {
          numberWeights[num] *= 0.9;
        });
        
        const totalWeight = numberWeights.reduce((sum, weight) => sum + weight, 0);
        const normalizedWeights = numberWeights.map(weight => weight / totalWeight);
        const cumulativeWeights = [];
        normalizedWeights.reduce((sum, weight, i) => {
          cumulativeWeights[i] = sum + weight;
          return sum + weight;
        }, 0);

        const random = Math.random();
        let selectedNumber = 0;
        for (let i = 0; i < cumulativeWeights.length; i++) {
          if (random <= cumulativeWeights[i]) {
            selectedNumber = i;
            break;
          }
        }

        return {
          number: selectedNumber,
          size: selectedNumber <= 4 ? 'small' : 'big',
          confidence: 0.6,
          reasoning: ['Weighted random selection based on frequency and recency'],
          factors: ['Weighted random selection']
        };
      }

      generateSmartRandomPrediction() {
        // Slightly bias toward the opposite of the last result if available
        let bias = 0.5;
        if (this.history.length > 0) {
          const lastNumber = this.history[0].number;
          bias = lastNumber <= 4 ? 0.6 : 0.4; // Slight bias toward opposite
        }
        
        const number = Math.random() < bias ? 
          Math.floor(Math.random() * 5) : 
          5 + Math.floor(Math.random() * 5);
          
        return { 
          number, 
          size: number <= 4 ? 'small' : 'big', 
          confidence: 0.5, 
          reasoning: ['Smart random prediction with slight bias'],
          factors: ['Smart random with bias']
        };
      }

      updateAccuracy(actualNumber) {
        if (!this.lastPrediction) return;
        this.accuracyStats.total++;
        
        const predictedSize = this.lastPrediction.size;
        const actualSize = actualNumber <= 4 ? 'small' : 'big';
        
        if (predictedSize === actualSize) {
          this.accuracyStats.correct++;
        }
      }

      getAccuracy() {
        return this.accuracyStats.total === 0 ? 0 : (this.accuracyStats.correct / this.accuracyStats.total) * 100;
      }
    }

    // Initialize advanced predictor
    const advancedAIPredictor = new AdvancedAIPredictor();

    // Sound management
    const playSound = (type) => {
      if (!soundEnabled) return;
      
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        switch(type) {
          case 'win':
            oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
            break;
          case 'loss':
            oscillator.frequency.setValueAtTime(392.00, audioContext.currentTime); // G4
            break;
          case 'notification':
            oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime); // E5
            break;
          default:
            oscillator.frequency.setValueAtTime(440.00, audioContext.currentTime); // A4
        }
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
      } catch (e) {
        console.log("Audio not supported");
      }
    };

    // Notification system
    const showNotification = (message, type = 'info', duration = 3000) => {
      notificationQueue.push({ message, type, duration });
      processNotificationQueue();
    };

    const processNotificationQueue = () => {
      if (isShowingNotification || notificationQueue.length === 0) return;
      
      isShowingNotification = true;
      const { message, type, duration } = notificationQueue.shift();
      const notification = document.getElementById('notification');
      const messageElement = document.getElementById('notificationMessage');
      
      messageElement.textContent = message;
      notification.className = `notification ${type}`;
      notification.classList.add('show');
      
      if (type !== 'info') {
        playSound('notification');
      }
      
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, 500);
      }, duration);
    };

    // Update last status with enhanced logic
    const updateLastStatus = (actualNumber) => {
      const resultType = actualNumber >= 5 ? 'BIG' : 'SMALL';
      const status = lastPrediction === resultType ? 'WIN' : 'LOSS';

      if (status === 'WIN') {
        winLevel = Math.min(winLevel + 1, 5);
        stats.streak = stats.streak + 1;
        consecutiveLosses = 0;
        stats.wins++;
        playSound('win');
        showNotification(`WIN! Prediction was correct.`, 'success');
      } else {
        winLevel = Math.max(0, winLevel - 1);
        stats.streak = 0;
        consecutiveLosses++;
        stats.losses++;
        playSound('loss');
        showNotification(`LOSS! Prediction was incorrect.`, 'error');
      }

      return { status, resultType };
    };

    // Format period number
    const formatPeriodNumber = () => {
      const now = new Date();
      now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
      const yearMonthDay = now.toISOString().slice(0, 10).replace(/-/g, '');
      const minutes = now.getHours() * 60 + now.getMinutes();
      return yearMonthDay + "1000" + (10001 + minutes);
    };

    // Format timer
    const pad = (num) => num.toString().padStart(2, '0');

    const formatTimer = () => {
      const now = new Date();
      now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
      const seconds = now.getSeconds();
      return `${pad(0)}:${pad(60 - seconds)}`;
    };

    // Get current date key
    const getCurrentDateKey = () => {
      const now = new Date();
      now.setTime(now.getTime() + (now.getTimezoneOffset() + 5.5 * 60) * 60 * 1000);
      return now.toISOString().slice(0, 10).replace(/-/g, '');
    };

    // Store Daily Pattern
    const storeDailyPattern = (result) => {
      const dateKey = getCurrentDateKey();
      if (!dailyPatterns[dateKey]) dailyPatterns[dateKey] = [];
      dailyPatterns[dateKey].push({
        number: Number(result.number),
        isBig: Number(result.number) >= 5,
        timestamp: Date.now()
      });

      // Clean up old patterns
      const dates = Object.keys(dailyPatterns).sort();
      if (dates.length > MAX_DAILY_PATTERNS) {
        dates.slice(0, dates.length - MAX_DAILY_PATTERNS).forEach(date => {
          delete dailyPatterns[date];
        });
      }
    };

    // Clean Old History
    const cleanOldHistory = () => {
      const now = Date.now();
      predictionHistory = predictionHistory.filter(item => {
        const timestamp = item.timestamp || now;
        return (now - timestamp) <= HISTORY_EXPIRY_MS;
      });

      if (predictionHistory.length > MAX_HISTORY) {
        predictionHistory = predictionHistory.slice(0, MAX_HISTORY);
      }
    };

    // Update color scheme
    function updateColorScheme() {
      const hue = Math.floor(Math.random() * 360);
      const saturation = Math.floor(Math.random() * 30) + 70;
      const lightness = Math.floor(Math.random() * 20) + 50;
      const primaryColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
      const primaryTransparent = primaryColor.replace(')', ', 0.2)').replace('hsl', 'hsla');
      const primaryHover = primaryColor.replace(')', ', 0.3)').replace('hsl', 'hsla');
      document.documentElement.style.setProperty('--primary-color', primaryColor);
      document.documentElement.style.setProperty('--primary-transparent', primaryTransparent);
      document.documentElement.style.setProperty('--primary-hover', primaryHover);
    }

    // Get Big/Small
    function getBigSmall(num) {
      return num >= 5 ? "BIG" : "SMALL";
    }

    // Get Color
    function getColor(num) {
      if ([1, 3, 7, 9].includes(num)) return "Green";
      if ([2, 4, 6, 8].includes(num)) return "Red";
      return "Violet";
    }

    // Update live time
    function updateLiveTime() {
      document.getElementById("liveTime").innerText = "Time: " + formatTimer();
    }

    // Update stats
    function updateStats() {
      const total = stats.wins + stats.losses;
      stats.accuracy = total > 0 ? ((stats.wins / total) * 100).toFixed(2) : 0;
      document.getElementById("totalWins").innerText = stats.wins;
      document.getElementById("totalLosses").innerText = stats.losses;
      document.getElementById("accuracy").innerText = `${stats.accuracy}%`;
      
      // Update streak indicator
      const streakDots = document.querySelectorAll('.streak-dot');
      streakDots.forEach((dot, index) => {
        dot.className = 'streak-dot';
        if (index < winLevel) {
          dot.classList.add('active');
        } else if (index < consecutiveLosses) {
          dot.classList.add('loss');
        }
      });
    }

    // Check internet speed
    async function checkInternetSpeed() {
      const statusElement = document.getElementById("serverStatus");
      if (!navigator.onLine) {
        statusElement.innerText = "Offline";
        statusElement.className = "offline";
        return;
      }

      try {
        const startTime = performance.now();
        await fetch('https://www.google.com', { mode: 'no-cors' });
        const endTime = performance.now();
        const latency = Math.round(endTime - startTime);
        const speed = latency < 200 ? "Fast" : latency < 500 ? "Medium" : "Slow";
        statusElement.innerText = `Online (${speed}, ${latency}ms)`;
        statusElement.className = "online";
      } catch (e) {
        statusElement.innerText = "Offline";
        statusElement.className = "offline";
      }
    }

    // Create prediction animation
    function createPredictionAnimation() {
      const container = document.querySelector('.card');
      const animation = document.createElement('div');
      animation.className = 'prediction-animation';
      container.appendChild(animation);
      
      for (let i = 0; i < 5; i++) {
        const pulse = document.createElement('div');
        pulse.className = 'pulse';
        pulse.style.left = `${Math.random() * 100}%`;
        pulse.style.top = `${Math.random() * 100}%`;
        pulse.style.animationDelay = `${i * 0.3}s`;
        animation.appendChild(pulse);
      }
      
      setTimeout(() => {
        container.removeChild(animation);
      }, 2000);
    }

    // API Fetch with Retry for History
    const fetchHistory = async (retryCount = 0) => {
      if (isFetching) return null;
      isFetching = true;
      try {
        const res = await fetch(HISTORY_API + '?ts=' + Date.now());
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        const data = await res.json();
        if (!data?.data?.list) throw new Error("Invalid response structure");
        return data.data.list;
      } catch (e) {
        console.error("History fetch error:", e.message);
        if (retryCount < API_MAX_RETRIES) {
          await new Promise(resolve => setTimeout(resolve, API_RETRY_INTERVAL));
          return fetchHistory(retryCount + 1);
        }
        return [];
      } finally {
        isFetching = false;
      }
    };

    // Fetch Current Period with Retry
    const fetchCurrentPeriod = async (retryCount = 0) => {
      try {
        const periodRes = await fetch(CURRENT_API, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ...REQUEST_DATA, timestamp: Math.floor(Date.now() / 1000) })
        });
        if (!periodRes.ok) throw new Error(`HTTP error! status: ${periodRes.status}`);
        const periodData = await periodRes.json();
        if (!periodData?.data?.issueNumber) throw new Error("Invalid response structure");
        return periodData.data.issueNumber;
      } catch (e) {
        console.error("Period fetch error:", e.message);
        if (retryCount < API_MAX_RETRIES) {
          await new Promise(resolve => setTimeout(resolve, API_RETRY_INTERVAL));
          return fetchCurrentPeriod(retryCount + 1);
        }
        return formatPeriodNumber();
      }
    };

    // Main data fetching function
    async function fetchData() {
      try {
        updateColorScheme();

        const period = await fetchCurrentPeriod();
        const list = await fetchHistory();
        let history = [];
        if (list.length > 0) {
          history = list.slice(0, 10).map(item => {
            const num = parseInt(item.number);
            return { period: item.issueNumber, number: num, resultType: getBigSmall(num), color: getColor(num), timestamp: Date.now() };
          });
          history.forEach(storeDailyPattern);
          advancedAIPredictor.history = history; // Update AdvancedAIPredictor history
        }

        if (period !== "Unavailable" && period !== lastFetchedPeriod) {
          // Clean old history
          cleanOldHistory();

          // Update previous prediction if pending
          if (predictionHistory.length > 0 && predictionHistory[0].resultStatus === "Pending") {
            const match = history.find(h => h.period === predictionHistory[0].period);
            if (match) {
              advancedAIPredictor.updateAccuracy(match.number);
              const { status, resultType } = updateLastStatus(match.number);
              predictionHistory[0].resultType = resultType;
              predictionHistory[0].resultStatus = status;
              predictionHistory[0].number = match.number;
              
              // Update result indicator
              const resultIndicator = document.querySelector('.result-indicator');
              resultIndicator.className = `result-indicator ${status.toLowerCase()}`;
              resultIndicator.textContent = status === 'WIN' ? '✓' : '✗';
              
              updateStats();
            }
          }

          // Generate new prediction with advanced AI
          const analysis = advancedAIPredictor.analyzeAdvancedPatterns(history);
          const aiDecision = advancedAIPredictor.generatePrediction(analysis);
          advancedAIPredictor.lastPrediction = aiDecision;

          lastPrediction = aiDecision.size === 'small' ? 'SMALL' : 'BIG';

          document.getElementById("currentPeriod").innerText = `Current Period: ${period}`;
          document.getElementById("predictionBox").innerText = `Prediction → ${lastPrediction}`;
          document.getElementById("confidenceBox").innerText = `Confidence: ${Math.round((aiDecision.confidence || 0.5) * 100)}%`;
          document.getElementById("patternBox").innerText = aiDecision.reasoning || '';

          // Show prediction details
          const predictionDetails = document.getElementById("predictionDetails");
          const predictionFactors = document.getElementById("predictionFactors");
          
          if (aiDecision.factors && aiDecision.factors.length > 0) {
            predictionFactors.innerHTML = aiDecision.factors.map(factor => `<li>${factor}</li>`).join('');
            predictionDetails.style.display = 'block';
          } else {
            predictionDetails.style.display = 'none';
          }

          // Reset result indicator to pending
          const resultIndicator = document.querySelector('.result-indicator');
          resultIndicator.className = 'result-indicator pending';
          resultIndicator.textContent = '?';

          // Add new prediction with timestamp
          if (!predictionHistory.find(p => p.period === period)) {
            predictionHistory.unshift({
              period: period,
              prediction: lastPrediction,
              resultType: "-",
              resultStatus: "Pending",
              number: null,
              timestamp: Date.now()
            });
            
            // Create animation for new prediction
            createPredictionAnimation();
          }

          lastFetchedPeriod = period;
        }

        updateStats();
        renderTable();
      } catch (e) {
        console.error("Unexpected error:", e.message);
        showNotification("Error fetching data. Retrying...", "error");
      }
    }

    // Render table based on active tab
    function renderTable() {
      const head = document.getElementById("tableHead");
      const body = document.getElementById("tableBody");

      if (document.getElementById("predTab").classList.contains("active")) {
        head.innerHTML = "<tr><th>Period</th><th>Prediction</th><th>Actual</th><th>Status</th></tr>";
        body.innerHTML = predictionHistory.length === 0
          ? "<tr><td colspan='4'>No predictions yet</td></tr>"
          : predictionHistory.map(item => `
            <tr>
              <td>${item.period}</td>
              <td>${item.prediction}</td>
              <td>${item.resultType}</td>
              <td><span class="status ${item.resultStatus.toLowerCase()}">${item.resultStatus.charAt(0)}</span></td>
            </tr>`).join("");
      } else if (document.getElementById("gameTab").classList.contains("active")) {
        head.innerHTML = "<tr><th>Period</th><th>Number</th><th>Big/Small</th><th>Color</th></tr>";
        body.innerHTML = "<tr><td colspan='4'>Loading game history...</td></tr>";
        fetch(HISTORY_API + '?ts=' + Date.now())
          .then(res => {
            if (!res.ok) {
              body.innerHTML = "<tr><td colspan='4'>Error loading game history</td></tr>";
              return;
            }
            return res.json();
          })
          .then(data => {
            if (!data?.data?.list) {
              body.innerHTML = "<tr><td colspan='4'>Error loading game history</td></tr>";
              return;
            }
            const history = data.data.list.slice(0, 10).map(item => {
              const num = parseInt(item.number);
              return { period: item.issueNumber, number: num, size: getBigSmall(num), color: getColor(num) };
            });
            body.innerHTML = history.map(item => {
              const colorClass = item.color.toLowerCase();
              return `
                <tr>
                  <td>${item.period}</td>
                  <td class="num ${colorClass}">${item.number}</td>
                  <td>${item.size}</td>
                  <td><span class="dot ${colorClass}"></span></td>
                </tr>`;
            }).join("");
          })
          .catch(e => {
            body.innerHTML = "<tr><td colspan='4'>Error loading game history</td></tr>";
            console.error("Game history error:", e.message);
          });
      } else {
        // AI Analysis Tab
        head.innerHTML = "<tr><th>Factor</th><th>Weight</th><th>Current Value</th></tr>";
        const analysis = advancedAIPredictor.analyzeAdvancedPatterns(advancedAIPredictor.history);
        if (analysis) {
          body.innerHTML = `
            <tr>
              <td>Streak Analysis</td>
              <td>${(advancedAIPredictor.patternWeights.streak * 100).toFixed(1)}%</td>
              <td>${analysis.sizeStreak}</td>
            </tr>
            <tr>
              <td>Alternation Rate</td>
              <td>${(advancedAIPredictor.patternWeights.alternation * 100).toFixed(1)}%</td>
              <td>${(analysis.sizeAlternation * 100).toFixed(1)}%</td>
            </tr>
            <tr>
              <td>Entropy</td>
              <td>${(advancedAIPredictor.patternWeights.entropy * 100).toFixed(1)}%</td>
              <td>${analysis.entropy.toFixed(2)}</td>
            </tr>
            <tr>
              <td>Cluster Analysis</td>
              <td>${(advancedAIPredictor.patternWeights.clusterAnalysis * 100).toFixed(1)}%</td>
              <td>Small: ${analysis.clusterAnalysis.smallAvg.toFixed(1)}, Big: ${analysis.clusterAnalysis.bigAvg.toFixed(1)}</td>
            </tr>
            <tr>
              <td>AI Accuracy</td>
              <td>N/A</td>
              <td>${advancedAIPredictor.getAccuracy().toFixed(1)}%</td>
            </tr>
          `;
        } else {
          body.innerHTML = "<tr><td colspan='3'>Insufficient data for analysis</td></tr>";
        }
      }
    }

    // Initialize particles background
    function initParticles() {
      particlesJS('particles-js', {
        particles: {
          number: { value: 80, density: { enable: true, value_area: 800 } },
          color: { value: "#00ffea" },
          shape: { type: "circle" },
          opacity: { value: 0.5, random: true },
          size: { value: 3, random: true },
          line_linked: {
            enable: true,
            distance: 150,
            color: "#00ffea",
            opacity: 0.2,
            width: 1
          },
          move: {
            enable: true,
            speed: 2,
            direction: "none",
            random: true,
            straight: false,
            out_mode: "out",
            bounce: false
          }
        },
        interactivity: {
          detect_on: "canvas",
          events: {
            onhover: { enable: true, mode: "repulse" },
            onclick: { enable: true, mode: "push" },
            resize: true
          }
        },
        retina_detect: true
      });
    }

    // Event listeners for tabs
    document.getElementById("predTab").onclick = () => {
      document.getElementById("predTab").classList.add("active");
      document.getElementById("gameTab").classList.remove("active");
      document.getElementById("aiTab").classList.remove("active");
      renderTable();
    };
    
    document.getElementById("gameTab").onclick = () => {
      document.getElementById("gameTab").classList.add("active");
      document.getElementById("predTab").classList.remove("active");
      document.getElementById("aiTab").classList.remove("active");
      renderTable();
    };
    
    document.getElementById("aiTab").onclick = () => {
      document.getElementById("aiTab").classList.add("active");
      document.getElementById("predTab").classList.remove("active");
      document.getElementById("gameTab").classList.remove("active");
      renderTable();
    };

    // Sound toggle
    document.getElementById("soundToggle").onclick = () => {
      soundEnabled = !soundEnabled;
      const soundToggle = document.getElementById("soundToggle");
      if (soundEnabled) {
        soundToggle.classList.remove("muted");
        showNotification("Sound enabled", "success", 2000);
      } else {
        soundToggle.classList.add("muted");
        showNotification("Sound disabled", "info", 2000);
      }
    };

    // Initialize the application
    function init() {
      initParticles();
      updateColorScheme();
      setInterval(updateLiveTime, 1000);
      setInterval(fetchData, UPDATE_INTERVAL);
      setInterval(checkInternetSpeed, 5000);
      fetchData();
      updateLiveTime();
      checkInternetSpeed();
      
      // Show welcome notification
      setTimeout(() => {
        showNotification("HEART LASS KING Engine Activated", "success", 4000);
      }, 1000);
    }

    // Start the application
    init();
  </script>
</body>
</html>